---
title: Design-Mode
tags: 设计模式,设计原则,常用模式
grammar_cjkRuby: true
---
## 设计模式
### 一 设计模式分类
	• 创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。
	• 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。
	• 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
### 二 设计模式遵循的原则
	1、开闭原则（Open Close Principle）
		对扩展开放，对修改关闭。
	2、里氏代换原则（Liskov Substitution Principle）
		只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真被复用，而衍生类也能够在基类的基础上增加新的行为。
	3、依赖倒转原则（Dependence Inversion Principle）
		这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。
	4、接口隔离原则（Interface Segregation Principle）
		使用多个隔离的借口来降低耦合度。
	5、迪米特法则（最少知道原则）（Demeter Principle）
		一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
	6、合成复用原则（Composite Reuse Principle）
		原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。		
### 设计模式原则之一——开闭原则
##### 定义

	   指的是一个软件实体应对扩展开发，对修改关闭(Software entities should be open for extension, but closed for modification)。这个原则是说在设计一个模块的时候，应对使这个模块可以在不被修改的前提下被扩展，换言之，应对可以不必修改源代码的情况下改变这个模块的行为。 
	   根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。
	   
		- 扩展开放：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。 

		- 修改关闭：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关闭的。
##### 例子
```java
interface Fruit   
{
 	public void plant();
	public void blossom();
	public void outcome();
}

class Apple implements Fruit   
{
	Apple() { this.plant(); }
	public void plant() { System.out.println("Plant a apple"); };
	public void blossom() { System.out.println("Apple blossomed"); };
	public void outcome() { System.out.println("Apple outcomed"); };
}

interface gardenerBase //Garden,是不能改变的.以后增加一个水果只需要 再写个类继承它!   
{
	public Fruit getFruit();
}

class AppleGardener implements gardenerBase//种植Apple的Garden   
{
	private static AppleGardener singleton;
	private AppleGardener() { ; }
	public static AppleGardener getGardener()
	{
		if (singleton == null)
			singleton  = new AppleGardener();
		return singleton;
	}
	
	public Fruit getFruit()
	{
		return new Apple();
	}
}

public class MyFirstOCPJAVA   
{
	public static void main(String []a)
	{
		Fruit tempApple;
		gardenerBase appleGarden  = AppleGardener.getGardener();
		tempApple  = appleGarden.getFruit();

		Fruit tempPear;
		gardenerBase pearGarden  = PearGardener.getGardener();
		tempPear  = pearGarden.getFruit();
	}
}  
```
### 设计模式原则之二——里氏替换原则
##### 一、定义
		里氏代换原则（Liskov Substitution Principle）
		所有引用基类的地方必须能透明地使用其子类的对象。	
##### 二、问题由来
		有一功能Fun，由类ClassOrg来完成。现在需要将功能Fun进行扩展，需要新增一子功能，其扩展后的功能为FunEx(FunEx由原有功能Fun和新功能FunSon组成)。功能FunEx由类ClassOrg及其子类ClassSon完成，子类ClassSon在完成新功能FunSon的同时有可能会导致原有功能Fun发生故障。
##### 三、解决方案
		解决：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
### 设计模式原则之三——依赖倒转原则
##### 一、定义
		依赖倒转原则（Dependence Inversion Principle）：
		A 高层模块不应该依赖底层模块，都应该依赖于抽象；
		B 抽象不应该依赖于具体，具体依赖于抽象	
##### 二、问题由来
		若高层依赖于底层，那么底层的变动也会导致高层的变动，这就会导致模块的复用性降低而且大大提高了开发的成本。若是依赖于抽象的话，那么是比较稳定的，底层或者高层的变动都不会互相影响。
##### 三、解决方案
		在项目的开发过程中遵循一个核心思想——“面向接口编程”。
###### 知识点：
	• 低层模块：系统不可分割的原子逻辑（会根据业务逻辑经常变化）
	• 高层模块：低层模块的再组合，对低层模块的抽象。
	• 抽象： 接口或抽象类（是底层模块的抽象，特点：不能直接被实例化）
	• 与接口或抽象类对应的实现类：低层模块的具体实现（特点：可以直拉被实例化）


	在面向对象的编程过程中，要写出低耦合高内聚的代码，需要遵循如下原则： 
	1. 模块间的依赖通过抽象类或接口发生，实现类之间的依赖关系也是通过抽象类或接口产生（实现类之间不应发生直接的依赖关系），降低系统的耦合性 
	2. 接口或抽象不依赖于实现类，但实现类依赖接口或抽象类，实现类对系统需要的功能具体实现，提高类的内聚!
###### 经典例子：
		公司是福特和本田公司的金牌合作伙伴，现要求开发一套自动驾驶系统，只要汽车上安装该系统就可以实现无人驾驶，该系统可以在福特和本田车上使用，只要这两个品牌的汽车使用该系统就能实现自动驾驶。
```c++
/*福特汽车类，包含三个方法，启动、停止、转弯*/
class FordCar
{
	public void Run()
	{
		Console.WriteLine("FordCar run");
	}
	
	public void Stop()
	{
		Console.WriteLine("FordCar stop");
	}
	
	public void Turn()
	{
		Console.WriteLine("FordCar turn");
	}
 }
 
 /*宏达汽车类，包含三个方法，启动、停止、转弯*/
class HondaCar
{
	public void Run()
	{
		Console.WriteLine("HondaCar run");
	}
	
	public void Stop()
	{
		Console.WriteLine("HondaCar stop");
	}
	
	public void Turn()
	{
		Console.WriteLine("HondaCar turn");
	}
}

/*自动驾驶系统，有三个方法启动汽车、停止汽车、汽车转向*/
  class AutoSystem
    {
        HondaCar hondaCar = new HondaCar();
        FordCar fordCar = new FordCar();
        CarType type;
        public AutoSystem(CarType type)
        {
            this.type = type;
        }
		
        public void RunCar()
        {
            if (type == CarType.Honda)
            {
                hondaCar.Run();
            }
            else if (type == CarType.Ford)
            {
                fordCar.Run();
            }
        }
		
        public void StopCar()
        {
            if (type == CarType.Honda)
            {
                hondaCar.Stop();
            }
            else if (type == CarType.Ford)
            {
                fordCar.Stop();
            }
        }
		
        public void TurnCar()
        {
            if (type == CarType.Honda)
            {
                hondaCar.Turn();
            }
            else if (type == CarType.Ford)
            {
                fordCar.Turn();
            }
        }
    }
```
		目前来看，是满足需求的，但是随着发展业务也在发展，现在如果发展了伙伴，需要对其他品牌的汽车添加自动驾驶系统，比如红旗、奇瑞等品牌，那么如果沿用以前的方式，就需要去修改AutoSystem了，先增加两个新的品牌汽车的对象，然后在启动汽车、停止汽车、汽车转向中进行修改增加分支语句对不同的品牌来进行判断然后加上各种操作，这样就违背的OCP，而且复杂的分支语句也会容易造成错误，如果以后再继续扩展其他的品牌的话，那么这样的程序肯定是不易于维护的，程序的健壮性是较差的，大大的增加了开发的成本。那么敏感的同学已经看出来，既然不同的汽车品牌之间都拥有相同的行为，那么为什么不定义一个接口呢？现在我们先来定义一个接口，然后将各个品牌的汽车实现这个接口实现，那么在AutoSystem中我们就可以针对定义的接口操作了。
```
/*汽车抽象出来的接口*/
    interface ICar
    {
        void Run();
        void Stop();
        void Turn();
     }
	
	/*自动驾驶系统（高层模块）现在针对的是这个抽象的接口，无论什么汽车，只要实现了ICar接口，就能进行相关的操作。*/
	 class AutoSystem
    {
        ICar car;
		
         public AutoSystem(ICar car)
        {
            this.car = car;
        }
		
         public void RunCar()
        {
            car.Run();
        }
		
         public void StopCar()
        {
            car.Stop();
        }
		
         public void TurnCar()
        {
            car.Turn();
        }
    }
	
	/*福特及宏达汽车类也就是底层模块，实现了ICar接口，现在依赖的是抽象的接口!*/
	 class FordCar : ICar
    {
        public void Run()
        {
            Console.WriteLine("FordCar run");
        }
		
         public void Stop()
        {
            Console.WriteLine("FordCar stop");
        }
		
        public void Turn()
        {
            Console.WriteLine("FordCar turn");
        }
    }

	 class HondaCar : ICar
    {
        public void Run()
        {
            Console.WriteLine("HondaCar run");
        }
		
        public void Stop()
        {
            Console.WriteLine("HondaCar stop");
        }
		
        public void Turn()
        {
            Console.WriteLine("HondaCar turn");
        }
    }

```
		当高层模块依赖底层的时候，那么高层的复用性就较差，就如上例所说的增加汽车品牌种类。如果高层与底层都是依赖于抽象的话，那么高层复用性就较好，因为通过继承象出来的接口实现多态，那么复用的地方就多了，这样的设计无疑是较为稳定的。	
		
### 设计模式原则之二——里氏替换原则
##### 一、定义
	接口隔离原则（Interface Segregation Principle）：
	客户端不应该依赖它不需要的接口； 一个类对另一个类的依赖应该建立在最小的接口上。
	
定义包含三层含义：
	• 一个类对另一个类的依赖应该建立在最小的接口上；
	• 一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口；
	• 不应该强迫客户依赖它们从来不用的方法。
##### 二、问题由来
		 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类C来说不是最小接口，而类B和类D必须去实现它们不需要的方法。下面通过一个UML图来说明这种现象：
		 ![enter description here](1543971538457.png)
##### 三、解决方案